(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.retextSimplify = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={
  "absorbtion": {
    "replace": "absorption"
  },
  "accidently": {
    "replace": "accidentally"
  },
  "acrossed": {
    "replace": "across"
  },
  "addicting": {
    "replace": "addictive"
  },
  "administrate": {
    "replace": "administer"
  },
  "ad nauseum": {
    "replace": "ad nauseam"
  },
  "advanced notice": {
    "replace": "advance notice"
  },
  "advocate for": {
    "replace": [
      "advocate",
      "campaign for"
    ]
  },
  "afterall": {
    "replace": "after all"
  },
  "ahold": {
    "replace": "hold"
  },
  "all and all": {
    "replace": "all in all"
  },
  "all be it": {
    "replace": "albeit"
  },
  "all do respect": {
    "replace": "all due respect"
  },
  "all for not": {
    "replace": "all for naught"
  },
  "all intensive purposes": {
    "replace": "all intents and purposes"
  },
  "all of the sudden": {
    "replace": "all of a sudden"
  },
  "alterior": {
    "replace": "ulterior"
  },
  "amature": {
    "replace": "amateur"
  },
  "ampitheater": {
    "replace": "amphitheater"
  },
  "and also": {
    "replace": [
      "and",
      "also"
    ]
  },
  "another words": {
    "replace": "in other words"
  },
  "any other number of": {
    "replace": "any number of other"
  },
  "anytime": {
    "replace": "any time"
  },
  "anyways": {
    "replace": "anyway"
  },
  "any where": {
    "replace": "anywhere"
  },
  "anywheres": {
    "replace": "anywhere"
  },
  "appauled": {
    "replace": "appalled"
  },
  "architected": {
    "replace": [
      "designed",
      "built"
    ]
  },
  "arthuritis": {
    "replace": "arthritis"
  },
  "artic": {
    "replace": "arctic"
  },
  "as best as": {
    "replace": "as best"
  },
  "as follow": {
    "replace": "as follows"
  },
  "as less as possible": {
    "replace": "as little as possible"
  },
  "as of yet": {
    "replace": "yet"
  },
  "as per": {
    "omit": true,
    "replace": "in accordance with"
  },
  "ascared": {
    "replace": "scared"
  },
  "asterick": {
    "replace": "asterisk"
  },
  "aswell": {
    "replace": "as well"
  },
  "ATM machine": {
    "replace": "ATM"
  },
  "athiest": {
    "replace": "atheist"
  },
  "avaidable": {
    "replace": "avoidable"
  },
  "awe, shucks": {
    "replace": "aw, shucks"
  },
  "baited breath": {
    "replace": "bated breath"
  },
  "baldfaced": {
    "replace": "barefaced"
  },
  "boldfaced": {
    "replace": "barefaced"
  },
  "barb wire": {
    "replace": "barbed wire"
  },
  "barbwire": {
    "replace": "barbed wire"
  },
  "bob wire": {
    "replace": "barbed wire"
  },
  "bobwire": {
    "replace": "barbed wire"
  },
  "BAR-B-Q": {
    "replace": "barbecue"
  },
  "barbeque": {
    "replace": "barbecue"
  },
  "based around": {
    "replace": "based on"
  },
  "based off": {
    "replace": "based on"
  },
  "based off of": {
    "replace": "based on"
  },
  "basicly": {
    "replace": "basically"
  },
  "basises": {
    "replace": "bases"
  },
  "beaurocracy": {
    "replace": "beauraucracy"
  },
  "beckon call": {
    "replace": "beck and call"
  },
  "between you and I": {
    "replace": "between you and me"
  },
  "beyond the pail": {
    "replace": "beyond the pale"
  },
  "bicep": {
    "replace": "biceps"
  },
  "blindsighted": {
    "replace": "blindsided"
  },
  "boast your confidence": {
    "replace": "bolster your confidence"
  },
  "bon a petite": {
    "replace": "bon appÃ©tit"
  },
  "bonafied": {
    "replace": "bona fide"
  },
  "boost in the arm": {
    "replace": "shot in the arm"
  },
  "bored of": {
    "replace": "bored with"
  },
  "born out of": {
    "replace": "born of"
  },
  "boughten": {
    "replace": "bought"
  },
  "bouyant": {
    "replace": "buoyant"
  },
  "brang": {
    "replace": "brought"
  },
  "brung": {
    "replace": "brought"
  },
  "brussel sprout": {
    "replace": "Brussels sprout"
  },
  "build off": {
    "replace": "build on"
  },
  "build off of": {
    "replace": "build on"
  },
  "butt naked": {
    "replace": "buck naked"
  },
  "buttload": {
    "replace": "boatload"
  },
  "buttox": {
    "replace": "buttocks"
  },
  "by far and away": {
    "replace": [
      "by far",
      "by far, far and away"
    ]
  },
  "caddy corner": {
    "replace": [
      "cater-corner",
      "catty-corner",
      "kitty-corner"
    ]
  },
  "calm, cool, and collective": {
    "replace": "calm, cool, and collected"
  },
  "capeesh": {
    "replace": "capisce"
  },
  "catched": {
    "replace": "caught"
  },
  "Caucasian": {
    "replace": "white"
  },
  "CD-ROM disk": {
    "replace": "CD-ROM"
  },
  "Ceasar": {
    "replace": "Caesar"
  },
  "cease the day": {
    "replace": "sieze the day"
  },
  "center around": {
    "replace": [
      "center on",
      "revolve around"
    ]
  },
  "centered around": {
    "replace": [
      "centered on",
      "revolved around"
    ]
  },
  "centers around": {
    "replace": [
      "centers on",
      "revolves around"
    ]
  },
  "center of attraction": {
    "replace": "center of attention"
  },
  "chai tea": {
    "replace": "chai"
  },
  "chalk-full": {
    "replace": [
      "chock-full",
      "chuck-full"
    ]
  },
  "chock it up": {
    "replace": "chalk it up"
  },
  "chrispy": {
    "replace": "crispy"
  },
  "closed-lipped": {
    "replace": "close-lipped"
  },
  "closed-minded": {
    "replace": "close-minded"
  },
  "closed-mouthed": {
    "replace": "close-mouthed"
  },
  "coat strings": {
    "replace": [
      "coat tails",
      "apron strings"
    ]
  },
  "coffee clutch": {
    "replace": [
      "coffee klatsch",
      "coffee klatch"
    ]
  },
  "cold slaw": {
    "replace": "cole slaw"
  },
  "compare and contrast": {
    "replace": "compare"
  },
  "comprised of": {
    "replace": "composed of"
  },
  "concensus": {
    "replace": "consensus"
  },
  "Confusionism": {
    "replace": "Confucianism"
  },
  "congradulations": {
    "replace": "congratulations"
  },
  "conservativism": {
    "replace": "conservatism"
  },
  "conversate": {
    "replace": "converse"
  },
  "copywrite": {
    "replace": "copyright"
  },
  "coronate": {
    "replace": "crown"
  },
  "could care less": {
    "replace": [
      "couldn't care less",
      "could not care less"
    ]
  },
  "could give a damn": {
    "replace": [
      "couldn't give a damn",
      "could not give a damn"
    ]
  },
  "could of": {
    "replace": [
      "could've",
      "could have"
    ]
  },
  "should of": {
    "replace": [
      "should've",
      "should have"
    ]
  },
  "cowtow": {
    "replace": "kowtow"
  },
  "Cracker Jacks": {
    "replace": "Cracker Jack"
  },
  "crucifiction": {
    "replace": "crucifixion"
  },
  "curve my appetite": {
    "replace": "curb my appetite"
  },
  "curve your appetite": {
    "replace": "curb your appetite"
  },
  "cut and dry": {
    "replace": "cut and dried"
  },
  "cut of tea": {
    "replace": "cup of tea"
  },
  "damp squid": {
    "replace": "damp squib"
  },
  "daring-do": {
    "replace": "derring-do"
  },
  "day in age": {
    "replace": "day and age"
  },
  "daylight savings time": {
    "replace": "daylight saving time"
  },
  "dealed": {
    "replace": "dealt"
  },
  "death nail": {
    "replace": [
      "death knell",
      "nail in the coffin"
    ]
  },
  "decimate": {
    "replace": [
      "annihilate",
      "slaughter",
      "wipe out"
    ]
  },
  "deep-seeded": {
    "replace": "deep-seated"
  },
  "definate": {
    "replace": "definite"
  },
  "denied of": {
    "replace": "denied"
  },
  "dieties": {
    "replace": "deities"
  },
  "different than": {
    "replace": "different from"
  },
  "digestive track": {
    "replace": "digestive tract"
  },
  "dire straights": {
    "replace": "dire straits"
  },
  "disasterous": {
    "replace": "disastrous"
  },
  "disconcerning": {
    "replace": [
      "concerning",
      "discerning"
    ]
  },
  "disembark the vessel": {
    "replace": "disembark"
  },
  "disgressions": {
    "replace": "discretion"
  },
  "disremember": {
    "replace": "forget"
  },
  "divide by half": {
    "replace": "divide in half"
  },
  "do's and don'ts": {
    "replace": "dos and don'ts"
  },
  "doesn't supposed to": {
    "replace": "isn't supposed to"
  },
  "donut": {
    "replace": "doughnut"
  },
  "doubtlessly": {
    "replace": "doubtless"
  },
  "drips and drabs": {
    "replace": "dribs and drabs"
  },
  "duck tape": {
    "replace": "duct tape"
  },
  "early adapter": {
    "replace": "early adopter"
  },
  "easedrop": {
    "replace": "eavesdrop"
  },
  "ect.": {
    "replace": "etc."
  },
  "efforting": {
    "replace": "trying"
  },
  "embaress": {
    "replace": "embarrass"
  },
  "emphasize on": {
    "replace": "emphasize"
  },
  "end result": {
    "replace": "result"
  },
  "enamored by": {
    "replace": "enamored of"
  },
  "enviroment": {
    "replace": "environment"
  },
  "epitomy": {
    "replace": "epitome"
  },
  "equally as": {
    "replace": [
      "equally",
      "as"
    ]
  },
  "ever so often": {
    "replace": "every so often"
  },
  "every since": {
    "replace": "ever since"
  },
  "everytime": {
    "replace": "every time"
  },
  "the exact same": {
    "replace": "exactly the same"
  },
  "excape": {
    "replace": "escape"
  },
  "excrable": {
    "replace": "execrable"
  },
  "execute on": {
    "replace": "execute"
  },
  "exhileration": {
    "replace": "exhilaration"
  },
  "expatriot": {
    "replace": "expatriate"
  },
  "expecially": {
    "replace": "especially"
  },
  "expresso": {
    "replace": "espresso"
  },
  "express that": {
    "replace": "say that"
  },
  "expresses that": {
    "replace": "says that"
  },
  "expressed that": {
    "replace": "said that"
  },
  "extract revenge": {
    "replace": "exact revenge"
  },
  "far be it for me": {
    "replace": "far be it from me"
  },
  "fastly": {
    "replace": "fast"
  },
  "Febuary": {
    "replace": "February"
  },
  "fellow classmate": {
    "replace": "classmate"
  },
  "fine toothcomb": {
    "replace": "fine-tooth comb"
  },
  "firey": {
    "replace": "fiery"
  },
  "firstable": {
    "replace": "first of all"
  },
  "fit to a tee": {
    "replace": "fit to a T"
  },
  "fits to a tee": {
    "replace": "fits to a T"
  },
  "flys": {
    "replace": "flies"
  },
  "focus around": {
    "replace": "focus on"
  },
  "focuses around": {
    "replace": "focuses on"
  },
  "focused around": {
    "replace": "focused on"
  },
  "followup": {
    "replace": [
      "follow up",
      "follow-up"
    ]
  },
  "for goodness' sakes": {
    "replace": "for goodness' sake"
  },
  "for sell": {
    "replace": "for sale"
  },
  "forsee": {
    "replace": "foresee"
  },
  "fourty": {
    "replace": "forty"
  },
  "foul swoop": {
    "replace": "fell swoop"
  },
  "fowl swoop": {
    "replace": "fell swoop"
  },
  "fully well": {
    "replace": "full well"
  },
  "fushia": {
    "replace": "fuschia"
  },
  "gardener snake": {
    "replace": "garter snake"
  },
  "gaurd": {
    "replace": "guard"
  },
  "Ghandi": {
    "replace": "Gandhi"
  },
  "gonna": {
    "replace": "going to"
  },
  "grammer": {
    "replace": "grammar"
  },
  "grasping for straws": {
    "replace": "grasping at straws"
  },
  "greatful": {
    "replace": "grateful"
  },
  "grievious": {
    "replace": "grievous"
  },
  "grill cheese": {
    "replace": "grilled cheese"
  },
  "gut-rending": {
    "replace": "gut-wrenching"
  },
  "had ought": {
    "replace": "ought"
  },
  "hadn't have": {
    "replace": "hadn't"
  },
  "heart-wrenching": {
    "replace": "heart-rending"
  },
  "hairbrained": {
    "replace": "harebrained"
  },
  "hand and hand": {
    "replace": "hand in hand"
  },
  "happy belated birthday": {
    "replace": "belated happy birthday"
  },
  "hardly never": {
    "replace": "hardly ever"
  },
  "hay day": {
    "replace": "heyday"
  },
  "HIV virus": {
    "replace": "HIV"
  },
  "he don't": {
    "replace": "he doesn't"
  },
  "hearing-impaired": {
    "replace": [
      "deaf",
      "hard-of-hearing"
    ]
  },
  "heighth": {
    "replace": "height"
  },
  "help the problem": {
    "replace": "help solve the problem"
  },
  "hence why": {
    "replace": "hence"
  },
  "hew and cry": {
    "replace": "hue and cry"
  },
  "highly looked upon": {
    "replace": "highly regarded"
  },
  "his and her's": {
    "replace": "his and hers"
  },
  "hisself": {
    "replace": "himself"
  },
  "an historic": {
    "replace": "a historic"
  },
  "hit and miss": {
    "replace": "hit or miss"
  },
  "hone in": {
    "replace": "home in"
  },
  "hyperderminc": {
    "replace": "hypodermic"
  },
  "ice tea": {
    "replace": "iced tea"
  },
  "impactful": {
    "replace": "influential"
  },
  "in memorial": {
    "replace": "immemorial"
  },
  "in regards to": {
    "replace": [
      "regarding",
      "with regard to"
    ]
  },
  "in route": {
    "replace": "en route"
  },
  "in tact": {
    "replace": "intact"
  },
  "in the fact that": {
    "replace": "by the fact that"
  },
  "incase": {
    "replace": "in case"
  },
  "incent": {
    "replace": "encourage"
  },
  "incentivize": {
    "replace": "encourage"
  },
  "incidently": {
    "replace": "incidentally"
  },
  "indepth": {
    "replace": [
      "in depth",
      "in-depth"
    ]
  },
  "indite": {
    "replace": "indict"
  },
  "infact": {
    "replace": "in fact"
  },
  "influencial": {
    "replace": "influential"
  },
  "in mass": {
    "replace": "en masse"
  },
  "in shambles": {
    "replace": "a shambles"
  },
  "insundry": {
    "replace": "and sundry"
  },
  "intend on": {
    "replace": [
      "intend to",
      "intent on"
    ]
  },
  "intergrate": {
    "replace": "integrate"
  },
  "interpretate": {
    "replace": "interpret"
  },
  "irregardless": {
    "replace": "regardless"
  },
  "Islams": {
    "replace": "Muslims"
  },
  "Isreal": {
    "replace": "Israel"
  },
  "jerry-rigged": {
    "replace": [
      "jury-rigged",
      "jerry-built"
    ]
  },
  "John Hopkins": {
    "replace": "Johns Hopkins"
  },
  "jutebox": {
    "replace": "jukebox"
  },
  "killed after": {
    "replace": [
      "killed by",
      "killed in",
      "died after"
    ]
  },
  "Kindergarden": {
    "replace": "Kindergarten"
  },
  "knots per hour": {
    "replace": "knots"
  },
  "koala bear": {
    "replace": "koala"
  },
  "LCD display": {
    "replace": [
      "LCD",
      "LCD screen"
    ]
  },
  "land lover": {
    "replace": "landlubber"
  },
  "laundrymat": {
    "replace": "laundromat"
  },
  "laundry mat": {
    "replace": "laundromat"
  },
  "laxadaisical": {
    "replace": "lackadaisical"
  },
  "lense": {
    "replace": "lens"
  },
  "less painless": {
    "replace": [
      "less painful",
      "more painless"
    ]
  },
  "libary": {
    "replace": "library"
  },
  "like for": {
    "replace": "like"
  },
  "likker": {
    "replace": "liquor"
  },
  "lip-sing": {
    "replace": [
      "lip-sync",
      "lip-synch"
    ]
  },
  "lip-singing": {
    "replace": [
      "lip-syncing",
      "lip-synching"
    ]
  },
  "little own": {
    "replace": "let alone"
  },
  "little to no": {
    "replace": "little or no"
  },
  "little to none": {
    "replace": "little or none"
  },
  "logon": {
    "replace": [
      "visit",
      "log on"
    ]
  },
  "lozenger": {
    "replace": "lozenge"
  },
  "maddening crowd": {
    "replace": "madding crowd"
  },
  "majorly": {
    "replace": "extremely"
  },
  "make due": {
    "replace": "make do"
  },
  "make pretend": {
    "replace": "make believe"
  },
  "marinate on": {
    "replace": [
      "ruminate on",
      "meditate on"
    ]
  },
  "marshall": {
    "replace": "marshal"
  },
  "marshmellow": {
    "replace": "marshmallow"
  },
  "mass quantities": {
    "replace": "massive quantities"
  },
  "mean for": {
    "replace": "mean"
  },
  "Medieval Ages": {
    "replace": "Middle Ages"
  },
  "meet up": {
    "replace": "meet"
  },
  "memorium": {
    "replace": "memoriam"
  },
  "middleaged": {
    "replace": "middle-aged"
  },
  "midrift": {
    "replace": "midriff"
  },
  "might could": {
    "replace": [
      "might",
      "could"
    ]
  },
  "might has well": {
    "replace": "might as well"
  },
  "might ought": {
    "replace": [
      "might",
      "ought"
    ]
  },
  "mind of information": {
    "replace": "mine of information"
  },
  "minuscule": {
    "replace": "minuscule"
  },
  "minus well": {
    "replace": "might as well"
  },
  "mischievious": {
    "replace": "mischievous"
  },
  "mispell": {
    "replace": "misspell"
  },
  "mispelled": {
    "replace": "misspelled"
  },
  "mispelling": {
    "replace": "misspelling"
  },
  "mixed-up media": {
    "replace": "mixed media"
  },
  "money is no option": {
    "replace": "money is no object"
  },
  "Mongoloid": {
    "omit": true
  },
  "mono e mono": {
    "replace": "mano a mano"
  },
  "more importantly": {
    "replace": "more important"
  },
  "most importantly": {
    "replace": "most important"
  },
  "moreso": {
    "replace": [
      "more",
      "more so"
    ]
  },
  "Moslem": {
    "replace": "Muslim"
  },
  "most always": {
    "replace": "almost always"
  },
  "motherload": {
    "replace": "mother lode"
  },
  "Mount Fujiyama": {
    "replace": [
      "Fujiyama",
      "Mount Fuji"
    ]
  },
  "much differently": {
    "replace": "very differently"
  },
  "muchly": {
    "replace": "much"
  },
  "mumble jumbo": {
    "replace": [
      "mumble jumble",
      "mumbo jumbo"
    ]
  },
  "mumbo jumble": {
    "replace": [
      "mumbo jumbo",
      "mumble jumble"
    ]
  },
  "must of": {
    "replace": "must have"
  },
  "mute point": {
    "replace": "moot point"
  },
  "myriad of": {
    "replace": "myriad"
  },
  "she don't": {
    "replace": "she doesn't"
  },
  "time progressed": {
    "replace": "time passed"
  },
  "time progresses": {
    "replace": "time passes"
  },
  "would of": {
    "replace": [
      "would've",
      "would have"
    ]
  }
}

},{}],2:[function(require,module,exports){
/**
 * @author Adam Hollett
 * @copyright 2016 Adam Hollett
 * @license MIT
 * @module retext:usage
 * @fileoverview Check for incorrect English usage.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var keys = require('object-keys');
var difference = require('array-differ');
var nlcstToString = require('nlcst-to-string');
var quotation = require('quotation');
var search = require('nlcst-search');
var patterns = require('./data/index.json');

/*
 * List of all phrases.
 */

var list = keys(patterns);

/**
 * Attacher.
 *
 * @param {Retext} processor
 *   - Instance.
 * @param {Object?} [options]
 *   - Configuration.
 * @param {Array.<string>?} [options.ignore]
 *   - List of phrases to *not* warn about.
 * @return {Function} - `transformer`.
 */
function attacher(processor, options) {
    var ignore = (options || {}).ignore || [];
    var phrases = difference(list, ignore);

    /**
     * Search `tree` for validations.
     *
     * @param {Node} tree - NLCST node.
     * @param {VFile} file - Virtual file.
     */
    function transformer(tree, file) {
        search(tree, phrases, function (match, position, parent, phrase) {
            var pattern = patterns[phrase];
            var replace = pattern.replace;
            var value = quotation(nlcstToString(match), 'â', 'â');
            var message;

            if (pattern.omit && !replace.length) {
                message = 'Remove ' + value;
            } else {
                message = 'Replace ' + value + ' with ' +
                    quotation(replace, 'â', 'â').join(', ');

                if (pattern.omit) {
                    message += ', or remove it';
                }
            }

            message = file.warn(message, {
                'start': match[0].position.start,
                'end': match[match.length - 1].position.end
            });

            message.ruleId = phrase;
            message.source = 'retext-usage';
        });
    }

    return transformer;
}

/*
 * Expose.
 */

module.exports = attacher;

},{"./data/index.json":1,"array-differ":3,"nlcst-search":8,"nlcst-to-string":9,"object-keys":10,"quotation":12}],3:[function(require,module,exports){
'use strict';
module.exports = function (arr) {
	var rest = [].concat.apply([], [].slice.call(arguments, 1));
	return arr.filter(function (el) {
		return rest.indexOf(el) === -1;
	});
};

},{}],4:[function(require,module,exports){
'use strict';

var toString = require('nlcst-to-string');

module.exports = isLiteral;

var single = {
  '-': true, // Hyphen-minus
  'â': true, // En dash
  'â': true, // Em dash
  ':': true, // Colon
  ';': true // Semi-colon
};

/* Pair delimiters. From common sense, and wikipedia:
 * Mostly from https://en.wikipedia.org/wiki/Quotation_mark. */
var pairs = {
  ',': {
    ',': true
  },
  '-': {
    '-': true
  },
  'â': {
    'â': true
  },
  'â': {
    'â': true
  },
  '"': {
    '"': true
  },
  '\'': {
    '\'': true
  },
  'â': {
    'â': true
  },
  'â': {
    'â': true
  },
  'â': {
    'â': true,
    'â': true
  },
  'â': {
    'â': true
  },
  'â': {
    'â': true
  },
  'â': {
    'â': true,
    'â': true
  },
  'Â«': {
    'Â»': true
  },
  'Â»': {
    'Â«': true
  },
  'â¹': {
    'âº': true
  },
  'âº': {
    'â¹': true
  },
  '(': {
    ')': true
  },
  '[': {
    ']': true
  },
  '{': {
    '}': true
  },
  'â¨': {
    'â©': true
  },
  'ã': {
    'ã': true
  }
};

/* Check if the node in `parent` at `position` is enclosed
 * by matching delimiters. */
function isLiteral(parent, index) {
  if (!(parent && parent.children)) {
    throw new Error('Parent must be a node');
  }

  if (isNaN(index)) {
    throw new Error('Index must be a number');
  }

  if (
    (!hasWordsBefore(parent, index) && nextDelimiter(parent, index, single)) ||
    (!hasWordsAfter(parent, index) && previousDelimiter(parent, index, single)) ||
    isWrapped(parent, index, pairs)
  ) {
    return true;
  }

  return false;
}

/* Check if the node in `parent` at `position` is enclosed
 * by matching delimiters. */
function isWrapped(parent, position, delimiters) {
  var prev = previousDelimiter(parent, position, delimiters);
  var next;

  if (prev) {
    next = nextDelimiter(parent, position, delimiters[toString(prev)]);
  }

  return Boolean(next);
}

/* Find the previous delimiter before `position` in
 * `parent`. Returns the delimiter node when found. */
function previousDelimiter(parent, position, delimiters) {
  var siblings = parent.children;
  var index = position;
  var result;

  while (index--) {
    result = delimiterCheck(siblings[index], delimiters);

    if (result === null) {
      continue;
    }

    return result;
  }

  return null;
}

/* Find the next delimiter after `position` in
 * `parent`. Returns the delimiter node when found. */
function nextDelimiter(parent, position, delimiters) {
  var siblings = parent.children;
  var index = position;
  var length = siblings.length;
  var result;

  while (++index < length) {
    result = delimiterCheck(siblings[index], delimiters);

    if (result === null) {
      continue;
    }

    return result;
  }

  return null;
}

/* Check if `node` is in `delimiters`. */
function delimiterCheck(node, delimiters) {
  var type = node.type;

  if (type === 'WordNode' || type === 'SourceNode') {
    return false;
  }

  if (type === 'WhiteSpaceNode') {
    return null;
  }

  return toString(node) in delimiters ? node : false;
}

/* Check if there are word nodes before `position`
 * in `parent`. */
function hasWordsBefore(parent, position) {
  return containsWord(parent, 0, position);
}

/* Check if there are word nodes before `position`
 * in `parent`. */
function hasWordsAfter(parent, position) {
  return containsWord(parent, position + 1, parent.children.length);
}

/* Check if parent contains word-nodes between
 * `start` and `end`. */
function containsWord(parent, start, end) {
  var siblings = parent.children;
  var index = start - 1;

  while (++index < end) {
    if (siblings[index].type === 'WordNode') {
      return true;
    }
  }

  return false;
}

},{"nlcst-to-string":5}],5:[function(require,module,exports){
'use strict';

module.exports = nlcstToString;

/* Stringify a NLCST node or list of nodes. */
function nlcstToString(node, separator) {
  var sep = separator || '';
  var values;
  var length;
  var children;

  if (!node || (!('length' in node) && !node.type)) {
    throw new Error('Expected node, not `' + node + '`');
  }

  if (typeof node.value === 'string') {
    return node.value;
  }

  children = 'length' in node ? node : node.children;
  length = children.length;

  /* Shortcut: This is pretty common, and a small performance win. */
  if (length === 1 && 'value' in children[0]) {
    return children[0].value;
  }

  values = [];

  while (length--) {
    values[length] = nlcstToString(children[length], sep);
  }

  return values.join(sep);
}

},{}],6:[function(require,module,exports){
'use strict';

var toString = require('nlcst-to-string');

module.exports = normalize;

var ALL = /[-']/g;
var DASH = /-/g;
var APOSTROPHE = /â/g;
var QUOTE = '\'';
var EMPTY = '';

/* Normalize `value`. */
function normalize(value, options) {
  var settings = options || {};
  var allowApostrophes = settings.allowApostrophes;
  var allowDashes = settings.allowDashes;
  var result = (typeof value === 'string' ? value : toString(value))
    .toLowerCase()
    .replace(APOSTROPHE, QUOTE);

  if (allowApostrophes && allowDashes) {
    return result;
  }

  if (allowApostrophes) {
    return result.replace(DASH, EMPTY);
  }

  if (allowDashes) {
    return result.replace(QUOTE, EMPTY);
  }

  return result.replace(ALL, EMPTY);
}

},{"nlcst-to-string":7}],7:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],8:[function(require,module,exports){
'use strict';

/* Dependencies. */
var visit = require('unist-util-visit');
var normalize = require('nlcst-normalize');
var isLiteral = require('nlcst-is-literal');

var own = {}.hasOwnProperty;

/* Expose. */
module.exports = search;

/* Constants. */
var C_SPACE = ' ';
var T_WORD = 'WordNode';
var T_WHITE_SPACE = 'WhiteSpaceNode';

/* Search. */
function search(tree, phrases, handler, options) {
  var settings = options || {};
  var apos = settings.allowApostrophes || options;
  var dashes = settings.allowDashes || false;
  var literals = settings.allowLiterals;
  var config = {allowApostrophes: apos, allowDashes: dashes};
  var byWord = {};
  var length;
  var index;
  var key;
  var firstWord;

  if (!tree || !tree.type) {
    throw new Error('Expected node');
  }

  if (typeof phrases !== 'object') {
    throw new Error('Expected object for phrases');
  }

  length = phrases.length;
  index = -1;

  if ('length' in phrases) {
    while (++index < length) {
      handlePhrase(phrases[index]);
    }
  } else {
    for (key in phrases) {
      handlePhrase(key);
    }
  }

  /* Search the tree. */
  visit(tree, T_WORD, visitor);

  /* Test a phrase.   */
  function test(phrase, position, parent) {
    var siblings = parent.children;
    var node = siblings[position];
    var count = siblings.length;
    var queue = [node];
    var expression = phrase.split(C_SPACE).slice(1);
    var length = expression.length;
    var index = -1;

    /* Move one position forward. */
    position++;

    /* Iterate over `expression`. */
    while (++index < length) {
      /* Allow joining white-space. */
      while (position < count) {
        node = siblings[position];

        if (node.type !== T_WHITE_SPACE) {
          break;
        }

        queue.push(node);
        position++;
      }

      node = siblings[position];

      /* Exit if there are no nodes left, if the
       * current node is not a word, or if the
       * current word does not match the search for
       * value. */
      if (
        !node ||
        node.type !== T_WORD ||
        normalize(expression[index], config) !== normalize(node, config)
      ) {
        return null;
      }

      queue.push(node);
      position++;
    }

    return queue;
  }

  /* Visitor for `WordNode`s.   */
  function visitor(node, position, parent) {
    var word;
    var phrases;
    var length;
    var index;
    var result;

    if (!literals && isLiteral(parent, position)) {
      return;
    }

    word = normalize(node, config);
    phrases = own.call(byWord, word) ? byWord[word] : [];
    length = phrases.length;
    index = -1;

    while (++index < length) {
      result = test(phrases[index], position, parent);

      if (result) {
        handler(result, position, parent, phrases[index]);
      }
    }
  }

  /* Handle a phrase. */
  function handlePhrase(phrase) {
    firstWord = normalize(phrase.split(C_SPACE, 1)[0], config);

    if (own.call(byWord, firstWord)) {
      byWord[firstWord].push(phrase);
    } else {
      byWord[firstWord] = [phrase];
    }
  }
}

},{"nlcst-is-literal":4,"nlcst-normalize":6,"unist-util-visit":13}],9:[function(require,module,exports){
/**
 * @author Titus Wormer
 * @copyright 2014-2015 Titus Wormer
 * @license MIT
 * @module nlcst:to-string
 * @fileoverview Transform an NLCST node into a string.
 */

'use strict';

/* eslint-env commonjs */

/**
 * Stringify an NLCST node.
 *
 * @param {NLCSTNode|Array.<NLCSTNode>} node - Node to to
 *   stringify.
 * @param {string} separator - Value to separate each item
 *   with.
 * @return {string} - Stringified `node`.
 */
function nlcstToString(node, separator) {
    var values;
    var length;
    var children;

    separator = separator || '';

    if (typeof node.value === 'string') {
        return node.value;
    }

    children = 'length' in node ? node : node.children;
    length = children.length;

    /*
     * Shortcut: This is pretty common, and a small performance win.
     */

    if (length === 1 && 'value' in children[0]) {
        return children[0].value;
    }

    values = [];

    while (length--) {
        values[length] = nlcstToString(children[length], separator);
    }

    return values.join(separator);
}

/*
 * Expose.
 */

module.exports = nlcstToString;

},{}],10:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":11}],11:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],12:[function(require,module,exports){
'use strict';

module.exports = quotation;

var C_DEFAULT = '"';

/* Quote text. */
function quotation(value, open, close) {
  var result;
  var index;
  var length;

  open = open || C_DEFAULT;
  close = close || open;

  if (typeof value === 'string') {
    return open + value + close;
  }

  if (typeof value !== 'object' || !('length' in value)) {
    throw new Error('Expected string or array of strings');
  }

  result = [];
  length = value.length;
  index = -1;

  while (++index < length) {
    result[index] = quotation(value[index], open, close);
  }

  return result;
}

},{}],13:[function(require,module,exports){
'use strict';

/* Expose. */
module.exports = visit;

/* Visit. */
function visit(tree, type, visitor, reverse) {
  if (typeof type === 'function') {
    reverse = visitor;
    visitor = type;
    type = null;
  }

  one(tree);

  /* Visit a single node. */
  function one(node, index, parent) {
    var result;

    index = index || (parent ? 0 : null);

    if (!type || node.type === type) {
      result = visitor(node, index, parent || null);
    }

    if (node.children && result !== false) {
      return all(node.children, node);
    }

    return result;
  }

  /* Visit children in `parent`. */
  function all(children, parent) {
    var step = reverse ? -1 : 1;
    var max = children.length;
    var min = -1;
    var index = (reverse ? max : min) + step;
    var child;

    while (index > min && index < max) {
      child = children[index];

      if (child && one(child, index, parent) === false) {
        return false;
      }

      index += step;
    }

    return true;
  }
}

},{}]},{},[2])(2)
});